{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { setRafTimeout, setRafInterval, clampValue, createSplitProps, match, isObject } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/timer.anatomy.ts\nvar anatomy = createAnatomy(\"timer\").parts(\"root\", \"area\", \"control\", \"item\", \"itemValue\", \"itemLabel\", \"actionTrigger\", \"separator\");\nvar parts = anatomy.build();\n\n// src/timer.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `timer:${ctx.id}:root`;\nvar getAreaId = ctx => ctx.ids?.area ?? `timer:${ctx.id}:area`;\n\n// src/timer.connect.ts\nvar validActions = /* @__PURE__ */new Set([\"start\", \"pause\", \"resume\", \"reset\", \"restart\"]);\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    computed,\n    scope\n  } = service;\n  const running = state.matches(\"running\");\n  const paused = state.matches(\"paused\");\n  const time = computed(\"time\");\n  const formattedTime = computed(\"formattedTime\");\n  const progressPercent = computed(\"progressPercent\");\n  return {\n    running,\n    paused,\n    time,\n    formattedTime,\n    progressPercent,\n    start() {\n      send({\n        type: \"START\"\n      });\n    },\n    pause() {\n      send({\n        type: \"PAUSE\"\n      });\n    },\n    resume() {\n      send({\n        type: \"RESUME\"\n      });\n    },\n    reset() {\n      send({\n        type: \"RESET\"\n      });\n    },\n    restart() {\n      send({\n        type: \"RESTART\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        id: getRootId(scope),\n        ...parts.root.attrs\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        role: \"timer\",\n        id: getAreaId(scope),\n        \"aria-label\": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,\n        \"aria-atomic\": true,\n        ...parts.area.attrs\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs\n      });\n    },\n    getItemProps(props2) {\n      const value = time[props2.type];\n      return normalize.element({\n        ...parts.item.attrs,\n        \"data-type\": props2.type,\n        style: {\n          \"--value\": value\n        }\n      });\n    },\n    getItemLabelProps(props2) {\n      return normalize.element({\n        ...parts.itemLabel.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getItemValueProps(props2) {\n      return normalize.element({\n        ...parts.itemValue.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.separator.attrs\n      });\n    },\n    getActionTriggerProps(props2) {\n      if (!validActions.has(props2.action)) {\n        throw new Error(`[zag-js] Invalid action: ${props2.action}. Must be one of: ${Array.from(validActions).join(\", \")}`);\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        hidden: match(props2.action, {\n          start: () => running || paused,\n          pause: () => !running,\n          reset: () => !running && !paused,\n          resume: () => !paused,\n          restart: () => false\n        }),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: props2.action.toUpperCase()\n          });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    validateProps(props2);\n    return {\n      interval: 1e3,\n      ...props2\n    };\n  },\n  initialState({\n    prop\n  }) {\n    return prop(\"autoStart\") ? \"running\" : \"idle\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      currentMs: bindable(() => ({\n        defaultValue: prop(\"startMs\") ?? 0\n      }))\n    };\n  },\n  watch({\n    track,\n    send,\n    prop\n  }) {\n    track([() => prop(\"startMs\")], () => {\n      send({\n        type: \"RESTART\"\n      });\n    });\n  },\n  on: {\n    RESTART: {\n      target: \"running:temp\",\n      actions: [\"resetTime\"]\n    }\n  },\n  computed: {\n    time: ({\n      context\n    }) => msToTime(context.get(\"currentMs\")),\n    formattedTime: ({\n      computed\n    }) => formatTime(computed(\"time\")),\n    progressPercent: ({\n      context,\n      prop\n    }) => {\n      const targetMs = prop(\"targetMs\");\n      if (targetMs == null) return 0;\n      const startMs = prop(\"startMs\") ?? 0;\n      const currentMs = context.get(\"currentMs\");\n      if (prop(\"countdown\")) {\n        return clampValue(toPercent(currentMs, targetMs, startMs), 0, 1);\n      }\n      return clampValue(toPercent(currentMs, startMs, targetMs), 0, 1);\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        START: {\n          target: \"running\"\n        },\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    \"running:temp\": {\n      effects: [\"waitForNextTick\"],\n      on: {\n        CONTINUE: {\n          target: \"running\"\n        }\n      }\n    },\n    running: {\n      effects: [\"keepTicking\"],\n      on: {\n        PAUSE: {\n          target: \"paused\"\n        },\n        TICK: [{\n          target: \"idle\",\n          guard: \"hasReachedTarget\",\n          actions: [\"invokeOnComplete\"]\n        }, {\n          actions: [\"updateTime\", \"invokeOnTick\"]\n        }],\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    paused: {\n      on: {\n        RESUME: {\n          target: \"running\"\n        },\n        RESET: {\n          target: \"idle\",\n          actions: [\"resetTime\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      keepTicking({\n        prop,\n        send\n      }) {\n        return setRafInterval(({\n          deltaMs\n        }) => {\n          send({\n            type: \"TICK\",\n            deltaMs\n          });\n        }, prop(\"interval\"));\n      },\n      waitForNextTick({\n        send\n      }) {\n        return setRafTimeout(() => {\n          send({\n            type: \"CONTINUE\"\n          });\n        }, 0);\n      }\n    },\n    actions: {\n      updateTime({\n        context,\n        prop,\n        event\n      }) {\n        const sign = prop(\"countdown\") ? -1 : 1;\n        const deltaMs = roundToInterval(event.deltaMs, prop(\"interval\"));\n        context.set(\"currentMs\", prev => {\n          const newValue = prev + sign * deltaMs;\n          let targetMs = prop(\"targetMs\");\n          if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n          if (prop(\"countdown\") && targetMs != null) {\n            return Math.max(newValue, targetMs);\n          } else if (!prop(\"countdown\") && targetMs != null) {\n            return Math.min(newValue, targetMs);\n          }\n          return newValue;\n        });\n      },\n      resetTime({\n        context,\n        prop\n      }) {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        context.set(\"currentMs\", prop(\"startMs\") ?? 0);\n      },\n      invokeOnTick({\n        context,\n        prop,\n        computed\n      }) {\n        prop(\"onTick\")?.({\n          value: context.get(\"currentMs\"),\n          time: computed(\"time\"),\n          formattedTime: computed(\"formattedTime\")\n        });\n      },\n      invokeOnComplete({\n        prop\n      }) {\n        prop(\"onComplete\")?.();\n      }\n    },\n    guards: {\n      hasReachedTarget: ({\n        context,\n        prop\n      }) => {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        if (targetMs == null) return false;\n        const currentMs = context.get(\"currentMs\");\n        return prop(\"countdown\") ? currentMs <= targetMs : currentMs >= targetMs;\n      }\n    }\n  }\n});\nfunction msToTime(ms) {\n  const time = Math.max(0, ms);\n  const milliseconds = time % 1e3;\n  const seconds = Math.floor(time / 1e3) % 60;\n  const minutes = Math.floor(time / (1e3 * 60)) % 60;\n  const hours = Math.floor(time / (1e3 * 60 * 60)) % 24;\n  const days = Math.floor(time / (1e3 * 60 * 60 * 24));\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  };\n}\nfunction toPercent(value, minValue, maxValue) {\n  const range = maxValue - minValue;\n  if (range === 0) return 0;\n  return (value - minValue) / range;\n}\nfunction padStart(num, size = 2) {\n  return num.toString().padStart(size, \"0\");\n}\nfunction roundToInterval(value, interval) {\n  return Math.floor(value / interval) * interval;\n}\nfunction formatTime(time) {\n  const {\n    days,\n    hours,\n    minutes,\n    seconds\n  } = time;\n  return {\n    days: padStart(days),\n    hours: padStart(hours),\n    minutes: padStart(minutes),\n    seconds: padStart(seconds),\n    milliseconds: padStart(time.milliseconds, 3)\n  };\n}\nfunction validateProps(props2) {\n  const {\n    startMs,\n    targetMs,\n    countdown,\n    interval\n  } = props2;\n  if (interval != null && (typeof interval !== \"number\" || interval <= 0)) {\n    throw new Error(`[timer] Invalid interval: ${interval}. Must be a positive number.`);\n  }\n  if (startMs != null && (typeof startMs !== \"number\" || startMs < 0)) {\n    throw new Error(`[timer] Invalid startMs: ${startMs}. Must be a non-negative number.`);\n  }\n  if (targetMs != null && (typeof targetMs !== \"number\" || targetMs < 0)) {\n    throw new Error(`[timer] Invalid targetMs: ${targetMs}. Must be a non-negative number.`);\n  }\n  if (countdown && startMs != null && targetMs != null) {\n    if (startMs <= targetMs) {\n      throw new Error(`[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than targetMs (${targetMs}).`);\n    }\n  }\n  if (!countdown && startMs != null && targetMs != null) {\n    if (startMs >= targetMs) {\n      throw new Error(`[timer] Invalid stopwatch configuration: startMs (${startMs}) must be less than targetMs (${targetMs}).`);\n    }\n  }\n  if (countdown && targetMs == null && startMs != null && startMs <= 0) {\n    throw new Error(`[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than 0 when no targetMs is provided.`);\n  }\n}\nvar segments = /* @__PURE__ */new Set([\"days\", \"hours\", \"minutes\", \"seconds\"]);\nfunction isTimeSegment(date) {\n  return isObject(date) && Object.keys(date).some(key => segments.has(key));\n}\nfunction parse(date) {\n  if (typeof date === \"string\") {\n    return new Date(date).getTime();\n  }\n  if (isTimeSegment(date)) {\n    const {\n      days = 0,\n      hours = 0,\n      minutes = 0,\n      seconds = 0,\n      milliseconds = 0\n    } = date;\n    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;\n    return value + milliseconds;\n  }\n  throw new Error(\"Invalid date\");\n}\nvar props = createProps()([\"autoStart\", \"countdown\", \"getRootNode\", \"id\", \"ids\", \"interval\", \"onComplete\", \"onTick\", \"startMs\", \"targetMs\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, parse, props, splitProps };","map":{"version":3,"names":["createAnatomy","setRafTimeout","setRafInterval","clampValue","createSplitProps","match","isObject","createMachine","createProps","anatomy","parts","build","getRootId","ctx","ids","root","id","getAreaId","area","validActions","Set","connect","service","normalize","state","send","computed","scope","running","matches","paused","time","formattedTime","progressPercent","start","type","pause","resume","reset","restart","getRootProps","element","attrs","getAreaProps","role","days","hours","minutes","seconds","getControlProps","control","getItemProps","props2","value","item","style","getItemLabelProps","itemLabel","getItemValueProps","itemValue","getSeparatorProps","separator","getActionTriggerProps","has","action","Error","Array","from","join","button","actionTrigger","hidden","onClick","event","defaultPrevented","toUpperCase","machine","props","validateProps","interval","initialState","prop","context","bindable","currentMs","defaultValue","watch","track","on","RESTART","target","actions","msToTime","get","formatTime","targetMs","startMs","toPercent","states","idle","START","RESET","effects","CONTINUE","PAUSE","TICK","guard","RESUME","implementations","keepTicking","deltaMs","waitForNextTick","updateTime","sign","roundToInterval","set","prev","newValue","Math","max","min","resetTime","invokeOnTick","invokeOnComplete","guards","hasReachedTarget","ms","milliseconds","floor","minValue","maxValue","range","padStart","num","size","toString","countdown","segments","isTimeSegment","date","Object","keys","some","key","parse","Date","getTime","splitProps"],"sources":["/Users/sofia-kalpin/Documents/Facu/ADR/Frontend/inmobiliaria-frontend/node_modules/@zag-js/timer/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { setRafTimeout, setRafInterval, clampValue, createSplitProps, match, isObject } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/timer.anatomy.ts\nvar anatomy = createAnatomy(\"timer\").parts(\n  \"root\",\n  \"area\",\n  \"control\",\n  \"item\",\n  \"itemValue\",\n  \"itemLabel\",\n  \"actionTrigger\",\n  \"separator\"\n);\nvar parts = anatomy.build();\n\n// src/timer.dom.ts\nvar getRootId = (ctx) => ctx.ids?.root ?? `timer:${ctx.id}:root`;\nvar getAreaId = (ctx) => ctx.ids?.area ?? `timer:${ctx.id}:area`;\n\n// src/timer.connect.ts\nvar validActions = /* @__PURE__ */ new Set([\"start\", \"pause\", \"resume\", \"reset\", \"restart\"]);\nfunction connect(service, normalize) {\n  const { state, send, computed, scope } = service;\n  const running = state.matches(\"running\");\n  const paused = state.matches(\"paused\");\n  const time = computed(\"time\");\n  const formattedTime = computed(\"formattedTime\");\n  const progressPercent = computed(\"progressPercent\");\n  return {\n    running,\n    paused,\n    time,\n    formattedTime,\n    progressPercent,\n    start() {\n      send({ type: \"START\" });\n    },\n    pause() {\n      send({ type: \"PAUSE\" });\n    },\n    resume() {\n      send({ type: \"RESUME\" });\n    },\n    reset() {\n      send({ type: \"RESET\" });\n    },\n    restart() {\n      send({ type: \"RESTART\" });\n    },\n    getRootProps() {\n      return normalize.element({\n        id: getRootId(scope),\n        ...parts.root.attrs\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        role: \"timer\",\n        id: getAreaId(scope),\n        \"aria-label\": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,\n        \"aria-atomic\": true,\n        ...parts.area.attrs\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs\n      });\n    },\n    getItemProps(props2) {\n      const value = time[props2.type];\n      return normalize.element({\n        ...parts.item.attrs,\n        \"data-type\": props2.type,\n        style: {\n          \"--value\": value\n        }\n      });\n    },\n    getItemLabelProps(props2) {\n      return normalize.element({\n        ...parts.itemLabel.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getItemValueProps(props2) {\n      return normalize.element({\n        ...parts.itemValue.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.separator.attrs\n      });\n    },\n    getActionTriggerProps(props2) {\n      if (!validActions.has(props2.action)) {\n        throw new Error(\n          `[zag-js] Invalid action: ${props2.action}. Must be one of: ${Array.from(validActions).join(\", \")}`\n        );\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        hidden: match(props2.action, {\n          start: () => running || paused,\n          pause: () => !running,\n          reset: () => !running && !paused,\n          resume: () => !paused,\n          restart: () => false\n        }),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({ type: props2.action.toUpperCase() });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({ props: props2 }) {\n    validateProps(props2);\n    return {\n      interval: 1e3,\n      ...props2\n    };\n  },\n  initialState({ prop }) {\n    return prop(\"autoStart\") ? \"running\" : \"idle\";\n  },\n  context({ prop, bindable }) {\n    return {\n      currentMs: bindable(() => ({\n        defaultValue: prop(\"startMs\") ?? 0\n      }))\n    };\n  },\n  watch({ track, send, prop }) {\n    track([() => prop(\"startMs\")], () => {\n      send({ type: \"RESTART\" });\n    });\n  },\n  on: {\n    RESTART: {\n      target: \"running:temp\",\n      actions: [\"resetTime\"]\n    }\n  },\n  computed: {\n    time: ({ context }) => msToTime(context.get(\"currentMs\")),\n    formattedTime: ({ computed }) => formatTime(computed(\"time\")),\n    progressPercent: ({ context, prop }) => {\n      const targetMs = prop(\"targetMs\");\n      if (targetMs == null) return 0;\n      const startMs = prop(\"startMs\") ?? 0;\n      const currentMs = context.get(\"currentMs\");\n      if (prop(\"countdown\")) {\n        return clampValue(toPercent(currentMs, targetMs, startMs), 0, 1);\n      }\n      return clampValue(toPercent(currentMs, startMs, targetMs), 0, 1);\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        START: {\n          target: \"running\"\n        },\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    \"running:temp\": {\n      effects: [\"waitForNextTick\"],\n      on: {\n        CONTINUE: {\n          target: \"running\"\n        }\n      }\n    },\n    running: {\n      effects: [\"keepTicking\"],\n      on: {\n        PAUSE: {\n          target: \"paused\"\n        },\n        TICK: [\n          {\n            target: \"idle\",\n            guard: \"hasReachedTarget\",\n            actions: [\"invokeOnComplete\"]\n          },\n          {\n            actions: [\"updateTime\", \"invokeOnTick\"]\n          }\n        ],\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    paused: {\n      on: {\n        RESUME: {\n          target: \"running\"\n        },\n        RESET: {\n          target: \"idle\",\n          actions: [\"resetTime\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      keepTicking({ prop, send }) {\n        return setRafInterval(({ deltaMs }) => {\n          send({ type: \"TICK\", deltaMs });\n        }, prop(\"interval\"));\n      },\n      waitForNextTick({ send }) {\n        return setRafTimeout(() => {\n          send({ type: \"CONTINUE\" });\n        }, 0);\n      }\n    },\n    actions: {\n      updateTime({ context, prop, event }) {\n        const sign = prop(\"countdown\") ? -1 : 1;\n        const deltaMs = roundToInterval(event.deltaMs, prop(\"interval\"));\n        context.set(\"currentMs\", (prev) => {\n          const newValue = prev + sign * deltaMs;\n          let targetMs = prop(\"targetMs\");\n          if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n          if (prop(\"countdown\") && targetMs != null) {\n            return Math.max(newValue, targetMs);\n          } else if (!prop(\"countdown\") && targetMs != null) {\n            return Math.min(newValue, targetMs);\n          }\n          return newValue;\n        });\n      },\n      resetTime({ context, prop }) {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        context.set(\"currentMs\", prop(\"startMs\") ?? 0);\n      },\n      invokeOnTick({ context, prop, computed }) {\n        prop(\"onTick\")?.({\n          value: context.get(\"currentMs\"),\n          time: computed(\"time\"),\n          formattedTime: computed(\"formattedTime\")\n        });\n      },\n      invokeOnComplete({ prop }) {\n        prop(\"onComplete\")?.();\n      }\n    },\n    guards: {\n      hasReachedTarget: ({ context, prop }) => {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        if (targetMs == null) return false;\n        const currentMs = context.get(\"currentMs\");\n        return prop(\"countdown\") ? currentMs <= targetMs : currentMs >= targetMs;\n      }\n    }\n  }\n});\nfunction msToTime(ms) {\n  const time = Math.max(0, ms);\n  const milliseconds = time % 1e3;\n  const seconds = Math.floor(time / 1e3) % 60;\n  const minutes = Math.floor(time / (1e3 * 60)) % 60;\n  const hours = Math.floor(time / (1e3 * 60 * 60)) % 24;\n  const days = Math.floor(time / (1e3 * 60 * 60 * 24));\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  };\n}\nfunction toPercent(value, minValue, maxValue) {\n  const range = maxValue - minValue;\n  if (range === 0) return 0;\n  return (value - minValue) / range;\n}\nfunction padStart(num, size = 2) {\n  return num.toString().padStart(size, \"0\");\n}\nfunction roundToInterval(value, interval) {\n  return Math.floor(value / interval) * interval;\n}\nfunction formatTime(time) {\n  const { days, hours, minutes, seconds } = time;\n  return {\n    days: padStart(days),\n    hours: padStart(hours),\n    minutes: padStart(minutes),\n    seconds: padStart(seconds),\n    milliseconds: padStart(time.milliseconds, 3)\n  };\n}\nfunction validateProps(props2) {\n  const { startMs, targetMs, countdown, interval } = props2;\n  if (interval != null && (typeof interval !== \"number\" || interval <= 0)) {\n    throw new Error(`[timer] Invalid interval: ${interval}. Must be a positive number.`);\n  }\n  if (startMs != null && (typeof startMs !== \"number\" || startMs < 0)) {\n    throw new Error(`[timer] Invalid startMs: ${startMs}. Must be a non-negative number.`);\n  }\n  if (targetMs != null && (typeof targetMs !== \"number\" || targetMs < 0)) {\n    throw new Error(`[timer] Invalid targetMs: ${targetMs}. Must be a non-negative number.`);\n  }\n  if (countdown && startMs != null && targetMs != null) {\n    if (startMs <= targetMs) {\n      throw new Error(\n        `[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than targetMs (${targetMs}).`\n      );\n    }\n  }\n  if (!countdown && startMs != null && targetMs != null) {\n    if (startMs >= targetMs) {\n      throw new Error(\n        `[timer] Invalid stopwatch configuration: startMs (${startMs}) must be less than targetMs (${targetMs}).`\n      );\n    }\n  }\n  if (countdown && targetMs == null && startMs != null && startMs <= 0) {\n    throw new Error(\n      `[timer] Invalid countdown configuration: startMs (${startMs}) must be greater than 0 when no targetMs is provided.`\n    );\n  }\n}\nvar segments = /* @__PURE__ */ new Set([\"days\", \"hours\", \"minutes\", \"seconds\"]);\nfunction isTimeSegment(date) {\n  return isObject(date) && Object.keys(date).some((key) => segments.has(key));\n}\nfunction parse(date) {\n  if (typeof date === \"string\") {\n    return new Date(date).getTime();\n  }\n  if (isTimeSegment(date)) {\n    const { days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } = date;\n    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;\n    return value + milliseconds;\n  }\n  throw new Error(\"Invalid date\");\n}\nvar props = createProps()([\n  \"autoStart\",\n  \"countdown\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"interval\",\n  \"onComplete\",\n  \"onTick\",\n  \"startMs\",\n  \"targetMs\"\n]);\nvar splitProps = createSplitProps(props);\n\nexport { anatomy, connect, machine, parse, props, splitProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}